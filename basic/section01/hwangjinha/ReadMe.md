# 강좌 소개
### JPA 실무에서 어려운 이유!
- 제대로 설계하고 매핑하는 법이 어렵다.
### 목표 - 객체와 테이블 설계 매핑
- 객체와 테이블 제대로 설계 & 매핑
- 기본 키 외래 키 매핑
- 1 : N, N : 1, 1 : 1, N : M 매핑
- 실무노하우 + 성능까지 고려
### 목표 - JPA 내부 동작 방식 이해
- JPA의 내부 동작 방식을 이해하지 못하고 사용
- JPA가 어떤 SQL을 만들어 내는지 이해
- JPA가 언제 SQL을 실행하는지 이해

# 섹션 1. JPA 소개
## SQL 중심적인 개발의 문제점
- 무한 반복, 지루한 코드
	- CRUD
	- 자바 객체를 SQL로... SQL을 자바 객체로...

### 객체와 관계형 DB의 차이
1. 상속 : 상속관계를 DB에 저장할 수는 없다. DB는 슈퍼타입 서브타입으로 상속을 대신한다.
2. 연관관계 : 객체는 참조를 사용. 테이블은 왜래 키를 사용
3. 데이터 타입
4. 데이터 식별 방법
**계층형 아키텍처 - 진정한 의미의 계층 분할이 어렵다**

## JPA 소개
### ORM
- 객체 관계 매핑
- 객체는 객체대로 설계
- ORM 프레임워크가 중간에서 매핑

#### JPA는 애플리케이션과 JDBC 사이에서 동작
### 동작 - 저장
![[Pasted image 20231214133331.png]]

### 동작 - 조회
![[Pasted image 20231214133415.png]]

### JPA 소개
- EJB 엔티티 빈
	- 표준이었지만 기술이 복잡하고 성능이 낮아 잘 사용되지 않았다.
- 하이버네이트
	- EJB를 많이 개선해 많이 사용되었다.
- JPA
	- 하이버네이트를 만든 개빈 킹을 데려와서 만들었다.
	- 실용적인 자바 표준

### JPA는 표준 명세
- JPA는 인터페이스의 모음
- 하이버네이트, EclipseLink, DataNucleus

### JPA를 왜 사용해야 하는가?
- 객체 중심 개발
- 생산성
- 유지보수 : 필드만 추가하면 된다.
- 패러다임 불일치 해결
- 성능
- 데이터 접근 추상화, 벤더 독립성
- 표준

### 생산성 - JPA와 CRUD
- 저장 : `jpa.persist(member)`
- 조회 : `Member member = jpa.find(memberId)`
- 수정 : `member.setName("변경할 이름")`
- 삭제 : `jpa.remove(member)`

### 유지보수
- 슈퍼 서브 관계 테이블을 알아서 join, insert 등을 필요한 테이블별로 나누어 수행해준다.

### JPA와 비교하기
- 동일한 트랜잭션 안에서 같은 조건으로 (memberId) 검색 시 반환되는 객체가 같음을 보장한다.

### JPA의 성능 최적화 기능
##### 1차 캐시와 동일성 보장
1. 같은 트랜잭션 안에서 같은 엔티티를 반환
	- 같은 엔티티를 반환할 때는 캐시된 객체를 반환
	- 약간의 조회 성능 향상
2. DB Isolation Level이 Read Commit이어도 애플리케이션에서 Repetable Read 보장
##### 트랜잭션을 지원하는 쓰기 지연 - Insert
1. 트랜잭션을 커밋할 때까지 INSERT SQL을 모음
2. JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송
##### 트랜잭션을 지원하는 쓰기 지연 - Update
##### 지연 로딩과 즉시 로딩
- 지연 로딩 : 객체가 실제 사용될 때 로딩
- 즉시 로딩 : JOIN SQL로 한번에 연관된 객체까지 미리 조회. JPA에 세팅을 해 놓아야 한다.

### ORM은 객체와 RDB 두 기둥 위에 있는 기술